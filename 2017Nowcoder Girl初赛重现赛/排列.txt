链接：https://ac.nowcoder.com/acm/contest/315/C
来源：牛客网

时间限制：C/C++ 1秒，其他语言2秒
空间限制：C/C++ 32768K，其他语言65536K
64bit IO Format: %lld
题目描述 
妞妞得到一个(1~n)的排列p1, p2, p3,...,pn, 听村里的老人牛牛说如果让这个排列变为:

对于所有的1 <= i <= n, 都满足pi ≠ i, 就可以获得Google Girl Hackathon的入场券。

妞妞仅允许的操作是: 交换排列中两个相邻的元素, 并且妞妞允许做这个操作任意次。

但是Google Girl Hackathon就快要开始了, 妞妞希望做最少的操作就使排列满足要求, 妞妞希望你能帮助她。

输入描述:
输入包括两行, 第一行包括一个正整数n(2 <= n <= 10^5), 表示排列的长度和范围。
第二行包括n个正整数p1, p2, p3,...,pn, 即妞妞得到的排列, 保证是一个1~n的排列。
输出描述:
输出一个整数, 表示妞妞需要的操作次数。
示例1
输入

5
1 4 3 5 2
输出

2
本题主要的题意就是使i位置上的数不等于i，因此对数组data采用遍历的方法，当data[i]=i+1时需要对i上面的数字相邻位置进行交换，理论上有几个data[i]=i+1的情况就需要交换几次，但是这里有种特殊情况，就是当data[i]=i+1并且满足data[i+1]=i+2时，虽然有两个值满足要求，但是由于是相邻的只需要交换一次即可。需要对这种情况进行讨论。即用i(i<n)表示数组的下标遍历数组，当没有相邻数字满足的时候，就每出现一次data[i]=i+1，将结果加1,同时i+=1；如果出现相邻数字满足时，结果加1，同时i+=2;依次遍历，直到遍历完数组。
